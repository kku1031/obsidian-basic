## 9 : 20 ~ 10 : 30
구조(Structor)
반복문(루프)
배열(Array)
선형
이진
목차(index) - 순서대로 - 인덱스를 가지고 있는거 
dictionary - 지멋대로 순서되있는거 
Key(키) : 알파벳 중심 
뭔가 찾는다 : 인덱스로 찾는거(리스트로 뒤진다), 키를 찾는다(딕셔너리)
검색 -> 조회수 순서로 나옴 -> 인공지능이 내놓는거 가장 많이 클릭한거 -> 가장 많이 클릭했다고 
답 아님. -> 최신 기술은 아님.

할일 : 회원가입 -> DB 저장 -> 회원 검색 -> 검색 할때 딕셔너리(키와 벨류의 집합) or 리스트(인덱스와 벨류)로 
키의 타입 : 인덱스(숫자 : int - 소수점 안됨) - 기계어, 키워드(문자) : String) - 자연어
책(데이터), 인덱스와 딕셔너리(구조)

자료 구조 : (Data Structure) - 포지셔닝 : 이게 최선인가?
`AI` : `line(ar)`(선형 구조, 리니어), `non-line` (비선형 구조)
파이썬 : `list`, `dictionary`
자바 : array + (`List`), Hash(`Map`) => list 안에 map이 있고  리스트 안일때 element/
리스트 밖일때 맵
자바스크립트 : `Array`, `json`(object) 

`Data(단수-자료)`와 `Data Structure(복수-자료들)` 차이
: Value(하나의 데이터 - 값 하나) :Values(자료구조)
로그인 반드시 하나만 존재해야 함 (유니크) : 하나만 있어야함. 

언어가 늘어나는 이유 : 최적화된 언어.

DataBase(언어가 아님) - 세계관
언어 : SQL(Structor - 복수형, Query(질의), Language)

러닝 스파크(빅데이터 분석)
데이터베이스 : 구조화된 데이터 = 데이터들 , 0개도 복수, 0개여도 데이터베이스임, 
값이 0개면 데이터가 없다., 빈칸을 만들었다. 구조 안에 하나다. 

## 10 : 30 ~ 11 : 20
데이터 웨어하우스 :데이터 베이스의 집합
아키텍쳐 : 규칙성(선형과 비선형)을 가진 구조
워크로드 : 데이터를 찾을 때 인덱스로 할지, 딕셔너리로 처리할지 실행하는 길. -> 커서가 실직적으로 가는 길 -> 커서의 안에 요소(Element) 
데이터 베이스 : 선형구조(엑셀) -> 비선형 구조(키워드로 DB 저장)
자료구조는 선형 -> 비선형, 비선형 -> 선형으로 왔다갔다함.
어떻게 가는게 좋을 지 구조화하는 기준점 : 최적화
자료구조 자체가 객체가됨.
element는 똑같은 인스턴스인데, 구조화된 곳에 들어가면 인스턴스고 구조화된 곳에서 안나오면 element

인스턴스와 인스턴스간의 비교 = 동등관계 
선형구조 안에서 array와 list로 갈림

SQL쿼리 : DB가 쓰는 언어(복수형 데이터만 처리한다)
스키마 : 
디스크 : 불변(디스크는 영원 불변 하다 = 영속성)
디스크 정보 : 데이터(저장된 값)
메모리의 정보 : Value (비저장된 값)
디스크상의 파일에 있는 데이터 및 인덱스의 내부 레이아웃을 고도로 최적화된 쿼리 처리 엔진과 긴밀하게 연결하여, 모든 읽기/쓰기 작업에 대하여 강력한 트랜잭션 ACID를 보장하고 저장된 데이터를 매우 빠르게 계산한다.


## 11 : 30 ~ 12 : 20
JPA -> 
스프링 데이터 : (디스크. ->  컴파일 필요없음. -> 타임 리프) 전자 정부 표준 데이터베이스 프레임 워크

JPA : object orient program 객체 지향(OOP) 기술이다. (글로벌 표준)

데이터베이스 : Base(거점, 저장소) - 디스크
깃허브 : 레포지토리 (저장소) - 메모리

![[Pasted image 20251020115733.png]]

스프링 , JPA, 비즈니스 로직(서비스) => 스프링 부트

레포지토리 = 엔티티(개체) 니까 기능을 빼야됨.
도메인 : 엔티티가 모여있는 계층 P498(JPA 프로그래밍)

=> `타임리프 - 컨트롤러 - 서비스 - 레포지토리 - DB` => 이 전체는 `파이프라인` + (뭐라뭐라된게 있음)

## 12 : 30 ~ 13 : 20
![[Pasted image 20251020125251.png]]
![[Pasted image 20251020130235.png]]
- 패턴 인식

## 14 : 30 ~ 15 : 20
데이터 베이스 : 공간
데이터셋 : 그안에 들어있는것(DB안에 있는 데이터)
![[Pasted image 20251020145055.png]]
![[Pasted image 20251020150141.png]]

![[Pasted image 20251020150932.png]]
 dependency - 의존성 주입(injection) => DI
 => 스파이더맨 거미의 능력을 집어넣다 
 => 기능 : ~를 할수 있는 능력
  => csv를 사용할 수 있는 능력 
 
## 15 : 30 ~ 16 : 20

코드 보기

A{ } - 클래스
a ( ) - 메소드
a ; - 실행문
a < > - 복수, 구조(자료구조)
a <<>> - 맵이 여러개 있는데 인덱스는 자동으로 붙어져 있다.

list를 돌릴때 for문을 씀.

## 16 : 30 ~ 17 : 20
![[Pasted image 20251020165449.png]]

- 911031 - 1263788
- 선형구조의 리스트 = element = 인덱스 0
- charAt(index :) 7번째꺼 가져와라.
- shift + alt + 화살표 아래 (한줄 복사) 
- ![[Pasted image 20251020170406.png]]
- 알고리즘 : 식과 문의 조합. 에 public 씌우면 메소드, 메소드를 감싸면 객체, 객체를 감싸면 스트럭처
- new , if else, return 다 핑크색 예약어(특별한 의미나 기능을 위해 미리 정해놓은 단어)
- if () {
 } 구조면 ()안에가 파라미터존이 아니라 ()안이 조건절 나머지는 파라미터 존
for, switch, while
- int a 변수 = 0;
- 연산자가 있어야 식이됨 => 알고리즘.
- if(a>2){
- }![[Pasted image 20251020171119.png]]
- 알고리즘을 가지고 있으면 비즈니스 로직이다.
## 17 : 20 ~ 18 : 20