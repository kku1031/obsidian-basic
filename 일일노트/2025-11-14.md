- @Bean : configration 연결 , @Component : 파이프라인(service, controller, repository)
- POJO : 노테이션, @Bean
- ![[Pasted image 20251114101916.png]] 
- @Bean이 @Configration 있으면 모놀리식이 되고 MSA구조로 가야하니까 Eureka로 바뀜.
- 스프링 세계에서 컴포넌트가 스프린부트가 되고 유레카가 컨피그레이션
- register : CPU 내부의 빠르고 작은 임시 저장 장치.
- ![[Pasted image 20251114104534.png]]
- 메모리에 로딩이 된 상태에서 어느 지점에 사용이 됨. 메모리 일부만 넘겨서 CPU에 사용한다.
- 
- 컴포넌트 스캔 : `스프링이 직접 개발자의 클래스를 찾아서 객체로 등록하는 자동 탐색 과정`을 의미합니다.
- 컴포넌트 스캔이 필요한 이유
- @Bean
- - 개발자가 명시적으로 설정파일에서 Bean을 생성해 등록.
- = 개발자가 구성을 직접 함, 그래서 안좋음
- <u>자동 감지 및 등록 : `@ComponentScan` 어노테이션이 설정된 클래스를 기준으로, 해당 패키지와 그 하위의 모든 패키지를 스캔</u>
- `스프링 컨텍스트(Spring Context)`, 즉 **스프링 컨테이너**에 `스프링 빈(Bean)`으로 등록
- ![[Pasted image 20251114105419.png]]
- @Id, Entity = 등록
- 빌더패턴 일때 모델(controller에서 model.attribute) Request 보내는거 : 화면에 보낼때
- 
- `@PersistenceContext` : `엔티티의 상태만 수동 관리`, 메모리에 있는 것 중에서 지금 쓰는 것.
- Repository가 스프링이 아니라면 레포지토리도 지꺼 가지고 있어야 한다. 영속성
- => 없어졌다가 QueryDSL을 사용하기 위해서 나옴. (매핑) 쿼리를 자바에서 하겠다 , JPA에서 끌고옴
- 
- 
- @Spring ApplicationContext 
- @Bean + @Context => `Bean(스프링 객체)를 관리`하는 Ioc컨테이너입니다.
-  
- AOP(관점 지향 프로그래밍)는 ==로깅, 트랜잭션(거래) 같은 부가 기능을 핵심 로직과 분리하여 관리하는 프로그래밍 패러다임== => 어느 사이트 가도 똑같은거. @transaction
- 
- `JPA : 인터페이스만` 작성해도 개발을 완료 할 수 있다. -> 클래스 만들 필요 X
- 계속 만들면 정적 상태 : 메모리에 계속 있다 = 느려짐
- 개발자가 `직접 구현체(클래스)` 를 개발 하지 않아도 된다.
-  
- ![[Pasted image 20251114131858.png]]
- 
- DB를 AOP뺴고, Repository도 AOP화
- ![[Pasted image 20251114145727.png]] 
- class -> JPA로 바꿀거임.
- - T, 추상화
- 
- Querydsl은 "자바 코드로 쓰는 JPQL" (JPA + SQL) 
- 엔티티-> 클래스 자동 생성
- QueryDsl 통합 : 
- 예전에는 검색 단발성 -> 쿼리, Criteria, 요즘은 chat gpt 처럼 길게 물어봄. 쿼리가 늘어남.
- 복잡한 쿼리, 동적 쿼리를 구현하는 데 있어 한계가 있다. 이러한 문제점을 해결할 수 있는 것
- ![[Pasted image 20251114154851.png]]
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 
- 

