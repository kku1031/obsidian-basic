## 2025-10-30
- 자바에서 @RequiredArgsConstructor 처럼 생성자랑 연결하는건 같은 언어끼리 매핑하는 거임
- `JPA 매핑 어노테이션`은 4가지로 분류 된당.(매핑 : 이기종언어 간의 연결)  
- 객체와 테이블 매핑 : @Entity, @Table
- 기본키 매핑 : @Id 
- 필드와 컬럼 매핑 : @Column(안쓰면 디폴트값임)
- 연관관계 매핑 : @ManyToOne, @JoinColumn //다대일(N:1) 관계, 외래키(FK) 컬럼 지정
- 
- JSON JavaScript Object(객체) <u>Notation</u> (표기): 가볍고 읽기 쉬운 텍스트 기반의 데이터 <u>교환형식</u> - `데이터나 개념을 표현` `그 언어가 뜻을 표기하는 방법`.  한글 , ㄱ,ㄴ,ㄷ,ㄹ 기본  `@자바 객체`라고 함. 
- -> 데이터 교환 포맷의 원조 언어 : XML 
- `기본 표기법` 
- <u>Annotation</u> - `코드나 문서에 설명/명령 추가`  `오리지날이 아니라 기능을 추가해준 것` : 이거를 이렇게 처리해라 `@Bean  객체`라고 함.
- `추가된 표기법`  노테이션을 생성함.(전역객체, 가비지컬렉터가 못지움, 한개만 존재, @Bean객체는 안 없어짐.) , `싱글톤 객체`를 만드는 것.  `DB 자동생성`
- 
- JPA는 표준이고(implement), 실제 일을 하는 건 Hibernate(Service)다.  
- Repository(스프링 꺼)
-  
- 어플리케이션컨텍스트 = ApiApplication
- 타입은 최상위 부모층에 준다.
-  ![[Pasted image 20251030110548.png]]
-  스프링이 new한게 안 없어짐. -> ProductRepository p = new ProductRepository 안해도 쓸수 있는 이름.
- ![[Pasted image 20251030110823.png]]
- 스프링 : 행위자 , 스프링 컨텍스트 : 스프링이 저장된 공간
- ![[Pasted image 20251030113729.png]]
-  soap : 공인 인증서 rest : 메신저 대화, 도커 YAML
-  DDL : 생성하는 렝귀지(실행 내부적)
- 
- 복수형이고 많을 때는 join이 효율적.
- 
- 자동형변환과 강제 형변환 -> 자동형변환 되는거는 걍 써라
-  | 바, || 컬럼
-  안티 패턴 <-> 디자인 패턴
-  -- SOCCER_SQL_011
-- 팀과 스타디움을 조인하여
-- 팀이름, 스타디움 이름 출력
-- 스타디움을 왼쪽에 두고, 홈팀이 없으면 해당 팀명에 "홈팀이 없음"
-- 으로 출력하시오.
-- 참고로 팀은 총 15개임. 스타디움은 총 20개임
select
	st.stadium_name 스타디움,
	coalesce(t.team_name,'홈팀이 없음') 팀명
from stadium st
left join team t on t.team_id=st.hometeam_id -- 컬럼 이름이 다르므로 ON 사용
				--문자열 데이터를 정렬하고 비교하는 규칙, 속성(attribute)
				--ucs_basic이라는 이름의 정렬 및 비교 규칙을 적용하여 문자열 순서를 결정	
order by t.team_name collate "ucs_basic";

-- SOCCER_SQL_012
-- 팀과 스타디움, 스케줄을 조인하여
-- 2012년 3월 17일에 열린 각 경기의
-- 팀이름, 스타디움, 어웨이팀 이름 출력
-- 다중테이블 join 을 찾아서 해결하시오.
-- 셀프 조인(Self-Join)은 같은 테이블의 데이터를 두 가지 이상의 다른 역할로 활용.
-- 테이블 내부의 행(row)들이 서로 관계를 맺고 있을 때

SELECT
    t.team_name 팀이름,
    s.stadium_name 스타디움,
    a.team_name 어웨이팀,
	sch.sche_date 경기일자
FROM schedule sch --180건
JOIN stadium s --20건
    USING (stadium_id)   
JOIN team t --15건
    ON sch.hometeam_id = t.team_id
JOIN team a
    ON sch.awayteam_id = a.team_id
WHERE sch.sche_date = '2012-03-17'
ORDER BY
    t.team_name ASC;

-- SOCCER_SQL_013
-- 2012년 3월 17일 경기에
-- 포항 스틸러스 소속 골키퍼(GK)
-- 선수, 포지션,팀명 (연고지포함),
-- 스타디움, 경기날짜를 구하시오
-- 연고지와 팀이름은 간격을 띄우시오

SELECT
    p.player_name 선수명,
    p.position 포지션,
    (t.region_name || ' ' || t.team_name) 팀명,
    s.stadium_name 스타디움,
    sch.sche_date 스케줄날짜
FROM player p
JOIN team t
	using (team_id)
JOIN schedule sch
    ON t.team_id IN (sch.hometeam_id, sch.awayteam_id)
JOIN stadium s
    ON sch.stadium_id = s.stadium_id
WHERE t.team_name = '스틸러스'
  AND p.position = 'GK'
  AND sch.sche_date = '2012-03-17'
ORDER BY
	p.player_name ASC;

-- SOCCER_SQL_014
-- 홈팀이 3점이상 차이로 승리한 경기의
-- 경기장 이름, 경기 일정
-- 리전 + 홈팀 이름과 원정팀 이름을, 그리고 추가로
-- 홈팀 점수와 원정팀 점수를
-- 구하시오

SELECT
    s.stadium_name 스타디움,
    sch.sche_date 경기날짜,
    ht.team_name 홈팀,
    home_score 홈팀 점수,
	away_score 원정팀 점수
FROM schedule sch
JOIN stadium s
	using (stadium_id)
JOIN team ht
    ON sch.hometeam_id = ht.team_id
JOIN team at
    ON sch.awayteam_id = at.team_id
WHERE (sch.home_score - sch.away_score) >= 3
ORDER BY
    sch.sche_date ASC;


-- SOCCER_SQL_015
-- STADIUM 에 등록된 운동장 중에서
-- 홈팀이 없는 경기장까지 전부 나오도록
-- 카운트 값은 20

-- SOCCER_SQL_015
SELECT 
    s.stadium_name "STADIUM_NAME",
    s.stadium_id "STADIUM_ID",
    s.seat_count "SEAT_COUNT",
    s.hometeam_id "HOMETEAM_ID",
    t.team_name "E_TEAM_NAME"
FROM 
    stadium s
LEFT JOIN 
    team t
ON 
    s.hometeam_id = t.team_id
ORDER BY 
    CASE WHEN s.hometeam_id IS NULL THEN 1 ELSE 0 END,
    s.hometeam_id ASC;






- 


